# Planning Notes

## Battleship Standard Game Rules

- 2 player game
- zero sum game
  - game ends in victory for 1 player and loss for the other
  - no tie possible
- win condition: a player has "sunk" every cell of every warship owned by the enemy player
- players consecutively alternate turns until one player wins regardless of whether a shot made is a miss or a hit
- game phases
  - warship placement
  - taking shots
- played with 4 boards
  - 2 boards for both players to place their ships
  - 2 boards for both players to mark their shots
  - each board is a 10 x 10 grid
- each player owns 5 total ships (1990 Milton Bradley version)
  - 1 x Carrier (of 1 x 5 cells)
  - 1 x Battleship (of 1 x 4 cells)
  - 1 x Cruiser (of 1 x 3 cells)
  - 1 x Submarine (of 1 x 3 cells)
  - 1 x Destroyer (of 1 x 2 cells)
- ship placement rules
  - a ship must be placed within the 10 x 10 board
  - a placed ship cannot be moved once placed or after the "warship placement" game phase is over
  - a ship can only be placed vertically or horizontally
  - a ship cannot be placed diagonally in either (negative or positive) direction
  - any cell occupied by a ship cannot overlap with any cell of an existing already placed (allied) ship
  - any cell that will be occupied by a ship must be a cell that is empty and in-bounds
- (calling) shot rules
  - a shot is a single cell or coordinate that is within the 10 x 10 board
  - each cell on the board can only be called at most once
    - a shot called on a cell that has already been called upon before is not valid
  - a shot is either a hit or a miss
    - a hit shot is one that matches the coordinate of some part of an enemy ship
    - a missed shot is one that does not match the coordinate of some part of an enemy ship

## MVP Requirements

- standard battleship game rules
- write (unit) tests for all non-UI app logic code via TDD
- code
  - has a `Ship` class / factory
  - has a `Gameboard` class / factory
  - has a `Player` class / factory
  - has a module for DOM / UI interaction
  - has a main game loop
  - has a `Game` module?
- functionality
  - allow each player to take a shot at the enemy player's board
  - allow each player to place their own ships
- human player vs computer player (algorithm)
- extras and optionals
  - allow human player to reset game
  - improve computer player algorithm but having it guess adjacent slots after getting a hit

## Pseudocode

- basic game loop for phase "warship placement"
  - exit loop if player has placed all their ships
  - get ship subarray region placement from player
  - if the ship placement is valid,
    - place the ship
    - decrement the count of to-be-placed ships for the current player
  - else
    - do nothing

- basic game loop for phase "taking shots"
  - exit loop if all of a player's ships have been sunk
    - end game and display game end result
  - get shot cell placement from current player
  - if the shot cell placement is valid,
    - place the shot
    - mark the cell as visited
    - if the shot was a hit,
      - update the enemy ship's state to indicate which part of it was hit
      - if enemy ship that was hit has no more hit points,
        - mark the ship as sunk
        - update the game state accordingly
    - else
      - mark the shot as a miss
  - else
    - keep prompting the player for a valid shot cell placement
  - switch the current turn to the other player

## Expanded Pseudocode

- `cell`: an int array of size 2 that represents a coordinate on the gameboard where
  - `cell[0]`: an int in range \[0, 9] that represents the row index on the board
  - `cell[1]`: an int in range \[0, 9] that represents the column index on the board
- `Ship` class
  - fields
    - `_length`: int in range \[0, 5]
    - `_hitCount`: int in range \[0, 5]
    - `_cells`: array or set of  `_length`-sized unique `cell`'s
  - `constructor(args)` constructor
    - TODO
  - getter and setter methods for all individual fields
  - `hit()` method
    - return if `hitCount` >= `length`
    - `hitCount++`
  - `isSunk()` method
    - returns `_hitCount` == `_length`
  - `onCell(cell)` method
    - returns true if `_cell` contains `cell` else false
- `Gameboard` class
  - fields
    - `_ROWS`: int set to 10
    - `_COLS`: int set to 10
    - `_MAX_SHIPS`: int set to 5
    - `_board`: 10 x 10 string 2D array where `_board[r][c]`
      - is `empty` for a non-occupied cell
      - is `miss` for a non-occupied cell that had a shot called on it
      - is `hit` for a ship-occupied cell that had a shot called on it
      - is `ship` for a ship-occupied cell that has not had a shot called on it
    - `_ships`: array of `Ship` instances
    - `_visitedCells`: set of `cell`s that have been visited or (shot) called by an enemy player
  - `constructor(args)` constructor
    - TODO
  - getter and setter methods for all individual fields
  - `isInboundCell(cell)`
    - `r` = `cell[0]`
    - `c` = `cell[1]`
    - return false if `cell` is not an array of size 2
    - return false if `c` is not an int in the range \[0, `_COLS` - 1]
    - return false if `r` is not an int in the range \[0, `_ROWS` - 1]
    - return true
  - `isEmptyCell(cell)`
    - `r` = `cell[0]`
    - `c` = `cell[1]`
    - return `_board[r][c]` == `empty`
  - `isShipCell(cell)`
    - `r` = `cell[0]`
    - `c` = `cell[1]`
    - return `_board[r][c]` == `ship` or `_board[r][c]` == `hit`
  - `isVisitedCell(cell)`
    - return true if `cell` is in `_visitedCells` else false
  - `canPlaceShipHorizontally(shipArgs, board)`
    - return false if `shipArgs.length` is not an int >= 1
    - return false if `shipArgs.hitCount` is not an int in the range \[0, `shipArgs.length`]
    - return false if `shipArgs.cells` is not array of size `shipArgs.length`
    - return false if `shipArgs.cells` contains any out-of-bounds `cell`s
    - return false if `shipArgs.cells` contains any duplicate `cell`s
    - return false if `shipArgs.cells` contains any cells that are not empty on the matrix board (`_board`)
    - return false if not all of `shipArgs.cells` are in the same row
    - return false if not all of `shipArgs.cells` form a contiguous subarray in the same row
    - return true
  - `canPlaceShipVertically(shipArgs, board)`
    - return false if `shipArgs.length` is not an int >= 1
    - return false if `shipArgs.hitCount` is not an int in the range \[0, `shipArgs.length`]
    - return false if `shipArgs.cells` is not array of size `shipArgs.length`
    - return false if `shipArgs.cells` contains any out-of-bounds `cell`s
    - return false if `shipArgs.cells` contains any duplicate `cell`s
    - return false if `shipArgs.cells` contains any cells that are not empty on the matrix board (`_board`)
    - return false if not all of `shipArgs.cells` are in the same column
    - return false if not all of `shipArgs.cells` form a contiguous subarray in the same column
    - return true
  - `indexOfShipWithCell(cell)`
    - return if `isShipCell(cell)` returns false
    - loop for each `ship` instance in `_ships`
      - if `ship.onCell(cell)` returns true,
        - return index of `ship`
    - return -1
  - `canPlaceShip(shipArgs)`
    - return false if size of `shipArgs.cells` != `shipArgs.length`
    - return false if there are duplicate subarray `cells` in `shipArgs.cells`
    - loop for each `cell` in `shipArgs.cells`
      - return false if not `isInboundCell(cell)`
      - return false if not `isEmptyCell(cell)`
      - TODO
  - `placeShip(shipArgs)`
    - return if `canPlaceShip(shipArgs)` returns false
    - creates a new `Ship` instance `ship`
    - pushes `ship` to `_ships` array
    - for each ship cell
      - update its coordinates on `_board` to `ship`
  - `receiveAttack(cell)`
    - if `isVisitedCell(cell)`, return
    - if size of `_ships` != `_MAX_SHIPS`, return
    - if `isShipCell(cell)`
      - `index` = `indexOfShipWithCell(cell)`
      - `_ships[index].hit()`
      - update `cell` on `_board` to `hit`
    - else
      - update `cell` on `_board` to `miss`
    - add `cell` to `_visitedCells`
  - `areAllShipsSunk()`
    - return false if size of `_ships` < `_MAX_SHIPS`
    - `sunkShips` = 0
    - loop for each `ship` instance in `_ships`
      - if `ship.isSunk()`
        - `sunkShips++`
    - return `sunkShips` == `_MAX_SHIPS`
- `Player` class
  - fields
    - `_id`: int set to 1 or 2
    - `_type`: string set to `human` or `computer`
  - `constructor(args)` constructor
    - TODO
  - getter and setter methods for all individual fields
  - `randomEmptyCell(board)`
    - return a randomly selected `cell` that is empty on the string matrix `board`
  - `randomShipCells(board, shipSizes)`
    - TODO
- `UIController` module
  - TODO
- `Game` module
  - fields
    - `_turnId`: int that represents the unique id of the `Player` instance whose turn it currently is
    - `_players`: TODO
    - `_boards`: TODO
    - `_uiControllerModule`: TODO
    - `_gameBoardClass`: TODO
    - `_playerClass`: TODO
  - `didPlayerWin(playerId)`
    - TODO
  - TODO
